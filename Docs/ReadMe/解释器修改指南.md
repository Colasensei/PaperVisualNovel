# executeLine() 解释器修改指南

## 概述

`executeLine()` 是PGN引擎的核心解释器函数，负责解析和执行单行PGN命令。本指南详细说明如何修改和扩展此函数。

## 函数签名

```cpp
std::pair<int, size_t> executeLine(
    const std::string& line,           // 要执行的命令行
    GameState& gameState,              // 游戏状态（可修改）
    size_t currentLine,                // 当前行号（0-based）
    const std::vector<std::string>& allLines, // 所有脚本行
    const std::string& where,          // 脚本所在目录路径
    int indentLevel,                   // 缩进级别（保留）
    const std::map<std::string, int>& labels // 标签映射表
);
```

**返回值：** `std::pair<int, size_t>`

- `first`：执行状态码
  - `0`：正常，继续下一行
  - `1`：跳转到指定行
  - `-1`：保存并退出
  - `-2`：不保存退出
- `second`：下一个要执行的行号（0-based索引）

## 函数结构

### 1. 初始化和注释处理（~行号 1-30）

```cpp
std::stringstream ss(line);
std::string cmd;
ss >> cmd;  // 提取命令关键字

// 跳过空行和注释
if (cmd.empty() || cmd == "//" || cmd == "#") {
    return { 0, currentLine + 1 };
}

// 跳过标签定义（以冒号结尾）
if (cmd.back() == ':') {
    return { 0, currentLine + 1 };
}
```

### 2. 命令分发结构（~行号 31-末尾）

```cpp
// 结束命令
if (cmd == "end" || cmd == "END") {
    // ... 处理逻辑
}

// 文本显示命令
if (cmd == "say" || cmd == "SAY") {
    // ... 处理逻辑
}

// 变量命令
if (cmd == "set" || cmd == "SET") {
    // ... 处理逻辑
}

// 选择命令
if (cmd == "choose" || cmd == "CHOOSE") {
    // ... 处理逻辑
}

// ... 其他命令

// 未知命令
MessageBoxA(NULL, ("错误：未知的PGN命令 - " + cmd).c_str(),
           "错误", MB_ICONERROR | MB_OK);
return { -1, 0 };
```

## 添加新命令的步骤

### 步骤1：确定命令位置

在命令分发结构中找到一个合适的位置添加新命令。建议按功能分组：

```cpp
// 建议分组顺序：
// 1. 流程控制命令（end, wait, jump等）
// 2. 文本命令（say, sayvar等）
// 3. 变量命令（set, random等）
// 4. 流程命令（choose, if等）
// 5. 多媒体命令（show等）
// 6. 新增命令
```

### 步骤2：编写命令处理代码

#### 模板：简单命令

```cpp
else if (cmd == "新命令" || cmd == "新命令大写") {
    // 1. 参数解析
    std::string param1, param2;
    if (!(ss >> param1 >> param2)) {
        // 参数不足的错误处理
        log(LogGrade::ERROR, "新命令: 参数不足");
        return { 0, currentLine + 1 };
    }

    // 2. 命令逻辑
    try {
        // 执行具体操作
        // 可以访问和修改 gameState
        // 可以读取脚本环境（allLines, labels等）

        // 示例：输出到日志
        log(LogGrade::INFO, "执行新命令: " + param1);

    } catch (const std::exception& e) {
        log(LogGrade::ERROR, std::string("新命令执行失败: ") + e.what());
    }

    // 3. 返回值
    return { 0, currentLine + 1 }; // 正常执行下一行
}
```

#### 模板：带跳转的命令

```cpp
else if (cmd == "jumpif" || cmd == "JUMPIF") {
    // 1. 参数解析
    std::string varName, op, valueStr, targetLabel;
    if (!(ss >> varName >> op >> valueStr >> targetLabel)) {
        log(LogGrade::ERROR, "jumpif: 参数格式错误");
        return { 0, currentLine + 1 };
    }

    // 2. 获取变量值
    int varValue = gameState.getVar(varName);
    int compareValue;
    try {
        compareValue = std::stoi(valueStr);
    } catch (...) {
        log(LogGrade::ERROR, "jumpif: 无效的数值: " + valueStr);
        return { 0, currentLine + 1 };
    }

    // 3. 条件判断
    bool conditionMet = false;
    if (op == "==") conditionMet = (varValue == compareValue);
    else if (op == "!=") conditionMet = (varValue != compareValue);
    else if (op == ">") conditionMet = (varValue > compareValue);
    else if (op == "<") conditionMet = (varValue < compareValue);
    else if (op == ">=") conditionMet = (varValue >= compareValue);
    else if (op == "<=") conditionMet = (varValue <= compareValue);
    else {
        log(LogGrade::ERROR, "jumpif: 无效的操作符: " + op);
        return { 0, currentLine + 1 };
    }

    // 4. 跳转处理
    if (conditionMet) {
        bool isLabel;
        int jumpLine = parseJumpTarget(targetLabel, labels, isLabel);
        if (jumpLine > 0 && jumpLine <= static_cast<int>(allLines.size())) {
            return { 1, jumpLine - 1 }; // 跳转到指定行
        } else {
            log(LogGrade::ERROR, "jumpif: 无效的跳转目标: " + targetLabel);
        }
    }

    // 5. 不跳转则继续下一行
    return { 0, currentLine + 1 };
}
```

### 步骤3：添加必要的头文件

如果需要新功能，在 `parser.cpp` 开头添加头文件：

```cpp
// 在 parser.cpp 开头添加
#include <新功能头文件.h>

// 示例：添加音效功能
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")
```

### 步骤4：更新相关文档

1. 更新语法文档（README.md 或专门文档）
2. 更新调试终端的帮助信息（如果需要）
3. 添加使用示例

## 实战示例

### 示例1：添加 `echo` 命令（简单显示）

```cpp
// 添加位置：在 say 命令后面
else if (cmd == "echo" || cmd == "ECHO") {
    // 读取剩余的所有内容作为消息
    std::string message;
    std::getline(ss, message);

    // 去除开头空格
    size_t start = message.find_first_not_of(" ");
    if (start != std::string::npos) {
        message = message.substr(start);
    }

    if (!message.empty()) {
        // 直接输出到控制台（无打字机效果）
        std::cout << message << std::endl;

        // 记录到日志
        log(LogGrade::INFO, "echo: " + message);
    }

    return { 0, currentLine + 1 };
}
```

### 示例2：添加 `clearscreen` 命令（清屏）

```cpp
// 添加位置：在流程控制命令区域
else if (cmd == "cls" || cmd == "CLS" || 
         cmd == "clearscreen" || cmd == "CLEARSCREEN") {

    // 清屏
    system("cls");

    // 可选：输出清屏提示
    std::string prompt;
    if (ss >> prompt && prompt == "silent") {
        // 静默模式，不输出任何内容
    } else {
        std::cout << "[屏幕已清空]" << std::endl;
    }

    return { 0, currentLine + 1 };
}
```

### 示例3：添加 `input` 命令（用户输入）

```cpp
// 添加位置：在交互命令区域
else if (cmd == "input" || cmd == "INPUT") {
    std::string varName, prompt;

    // 读取变量名和提示信息
    if (!(ss >> varName)) {
        log(LogGrade::ERROR, "input: 需要指定变量名");
        return { 0, currentLine + 1 };
    }

    // 读取提示信息（可能包含空格）
    std::getline(ss, prompt);
    size_t start = prompt.find_first_not_of(" ");
    if (start != std::string::npos) {
        prompt = prompt.substr(start);
    }

    // 显示提示
    if (!prompt.empty()) {
        std::cout << prompt << ": ";
    } else {
        std::cout << "请输入: ";
    }

    // 获取用户输入
    std::string userInput;
    std::getline(std::cin, userInput);

    // 尝试转换为整数
    try {
        int value = std::stoi(userInput);
        gameState.setVar(varName, value);
        log(LogGrade::INFO, "input: 设置变量 " + varName + " = " + std::to_string(value));
    } catch (...) {
        // 如果不是数字，可以存储为字符串（如果未来支持字符串变量）
        log(LogGrade::WARNING, "input: 输入不是有效数字，变量设置为0");
        gameState.setVar(varName, 0);
    }

    return { 0, currentLine + 1 };
}
```

## 访问可用资源

### 1. 游戏状态 (`gameState`)

```cpp
// 读写变量
gameState.setVar("score", 100);
int score = gameState.getVar("score");

// 检查变量存在
if (gameState.hasVar("flag")) {
    // 变量存在
}

// 获取所有变量
const auto& allVars = gameState.getAllVariables();

// 结局管理
gameState.addEnding("good_ending");
int collected = gameState.getCollectedEndingsCount();

// 选择历史
gameState.recordChoice("选择了选项A");
const auto& history = gameState.getChoiceHistory();
```

### 2. 脚本环境

```cpp
// 当前脚本行
std::string currentCmd = allLines[currentLine];

// 总行数
size_t totalLines = allLines.size();

// 跳转到特定行（通过标签）
bool isLabel;
int lineNum = parseJumpTarget("chapter2", labels, isLabel);

// 脚本目录（用于构建资源路径）
std::string imagePath = where + "archive\\image.jpg";
```

### 3. 用户交互

```cpp
// 文本输出（带打字机效果）
vnout("文本", 0.5, blue, true, true);

// 等待用户按键
int result = operate();  // 返回操作结果

// 直接获取按键
std::string key = getKeyName();
```

## 重要注意事项

### 1. 错误处理

```cpp
// 必须添加适当的错误处理
try {
    // 可能抛出异常的操作
    int value = std::stoi(str);
} catch (const std::exception& e) {
    log(LogGrade::ERROR, std::string("转换失败: ") + e.what());
    return { 0, currentLine + 1 }; // 不要终止游戏
}

// 使用日志记录错误
log(LogGrade::WARNING, "参数可能无效: " + param);
```

### 2. 内存安全

```cpp
// 避免内存泄漏
// 如果分配了资源，确保释放

// 示例：文件操作
std::ifstream file(path);
if (!file.is_open()) {
    log(LogGrade::ERROR, "无法打开文件: " + path);
    return { 0, currentLine + 1 };
}
// 文件会在离开作用域时自动关闭
```

### 3. 性能考虑

```cpp
// 避免在命令中执行耗时操作
// 如果需要，可以添加延迟或异步执行

// 不好的做法：在命令中执行复杂计算
// 好的做法：预先计算或使用缓存
```

### 4. 保持兼容性

```cpp
// 新命令不应破坏现有脚本
// 考虑向后兼容性

// 示例：添加可选参数
std::string param1, param2;
if (ss >> param1) {
    // 有第一个参数
    if (ss >> param2) {
        // 有两个参数
    } else {
        // 只有一个参数，使用默认值
        param2 = "default";
    }
}
```

## 测试新命令

### 1. 创建测试脚本

```pgn
# test_new_command.pgn
start:
    # 测试 echo 命令
    echo "这是一个测试消息"

    # 测试 input 命令
    input age "请输入你的年龄"
    sayvar age 0.3

    # 测试 clearscreen 命令
    wait 1000
    clearscreen

    # 测试新命令的错误处理
    echo  # 无参数应该正常处理

    end
```

### 2. 使用调试终端

```
Debug> goto 1      # 跳转到测试脚本
Debug> vars        # 查看变量变化
Debug> log info "测试新命令"
```

### 3. 查看日志文件

```
# 检查 pvn_engine.log
[时间] INFO  echo: 这是一个测试消息
[时间] INFO  input: 设置变量 age = 25
```

## 修改现有命令

### 示例：增强 `say` 命令

```cpp
// 在现有的 say 命令处理中添加新功能
if (cmd == "say" || cmd == "SAY") {
    // 现有代码...

    // 添加新特性：支持说话者名称
    std::string speaker;
    if (rest.find(":") != std::string::npos) {
        // 新格式：说话者: 对话内容
        size_t colonPos = rest.find(":");
        speaker = rest.substr(0, colonPos);
        rest = rest.substr(colonPos + 1);

        // 显示说话者（不同颜色）
        vnout(speaker + ": ", 0.1, yellow, false, false);
    }

    // 继续原有的文本处理...
}
```

## 性能分析

### 命令执行时间监控

```cpp
// 在 executeLine 开头添加
auto startTime = std::chrono::high_resolution_clock::now();

// 在返回前添加
auto endTime = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);

if (duration.count() > 1000) { // 超过1毫秒
    log(LogGrade::WARNING, "命令 " + cmd + " 执行时间较长: " + 
        std::to_string(duration.count()) + "μs");
}
```

## 最佳实践总结

### Do's（应该做的）

 添加充分的错误处理  
 使用日志记录重要操作  
 保持向后兼容性  
 编写清晰的注释  
 测试各种边界情况  

### Don'ts（不应该做的）

 直接修改全局变量（使用 gameState）  
 在命令中执行耗时操作  
 忽略用户输入验证  
 使用未初始化的变量  
 忘记释放资源  

## 相关文件

需要同时修改的文件：

1. `parser.cpp` - 主解释器实现
2. `parser.h` - 函数声明（如果需要暴露新函数）
3. `ui.h` - 如果需要新UI功能
4. `gamestate.h` - 如果需要新游戏状态功能
5. 文档文件 - 更新语法说明

## 技术支持

### 常见问题

1. **命令不执行**：检查命令关键字大小写
2. **参数解析错误**：检查空格分隔和引号使用
3. **跳转失败**：检查标签是否存在
4. **变量不更新**：检查变量名拼写

### 调试技巧

```cpp
// 临时添加调试输出
std::cout << "DEBUG: 执行命令 " << cmd << std::endl;
std::cout << "DEBUG: 剩余参数: " << ss.str() << std::endl;

// 使用日志系统
log(LogGrade::DEBUG, "执行命令: " + cmd);
log(LogGrade::DEBUG, "当前行: " + std::to_string(currentLine));
```

---

**版本：** 解释器修改指南 v1.0  
**最后更新：** 2026年1月17日  
**适用版本：** PGN引擎 Alpha 1.0+

通过本指南，你应该能够安全、有效地扩展PGN解释器的功能。记得在修改前备份代码，并充分测试新功能！
